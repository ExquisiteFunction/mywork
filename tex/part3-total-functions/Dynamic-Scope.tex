\section{动态作用域}

由规则(8.5)定义的动态函数应用只涉及表达式而不涉及自由变量。
当一个函数被应用时，参数会替换参变量，以确保结果是闭的。
此外，由于闭表达式的替代永远不会被捕获，所以变量的范围不会受动态影响，
这样可以确保第一章中描述的绑定和作用域规则得到遵守。
对变量的这种处理方式我们称之为\textbf{静态作用域}，或是\textbf{静态绑定}，以便对我们现在讨论的方法加以区分。

另一种方法，被称为\textbf{动态作用域}，或是\textbf{动态绑定}，有时被提倡作为静态绑定的替代方法。
关键的区别在于，在动态作用域中，确定abt的重命名绑定变量的原则不再适用。
因此避免捕捉的替换不再适用。
相反，求值是由开项定义的，其中自由变量的绑定是由环境将变量名映射到（开）值来提供的。
变量的绑定被尽可能的推迟，在求值处被绑定，而不是在绑定处。
如果环境不能提供一个变量的绑定，那么求值会报运行时错误。

对一阶函数而言，动态和静态作用域是一致的，但是对高阶函数来说这两者不完全相同。
例如，在对表达式$(\lambda(x:\mathsf{num})x+7)(42)$求值时动态和静态作用域一致。
不论是在求值前将$x$替换为42，还是在求值时将$x$绑定到42，最终结果是一致的。

在高阶函数中，静态和动态作用域不再相等。例如，考虑下面的表达式：
$$e \triangleq (\lambda(x:\mathsf{num})\lambda(y:\mathsf{num})x+y)(42)$$
在静态作用域中，对$e$求值得到闭值$v \triangleq \lambda(y:\mathsf{num})42+y$，
该值在应用时会在参数上加$42$。不论绑定变量$x$如何选取，结果总是相同的。
在动态作用域中，对$e$求值得到开值$v' \triangleq \lambda(y:\mathsf{num})x+y$,
其中的变量$x$是自由的。在表达式被求值的时候，变量$x$被绑定到$42$，
但这是不相关的，因为绑定不需要对$\lambda$抽象求值。
$x$的绑定直到$v'$应用到参数上才被检索，而不是在对$e$求值的时候。

这就存在差异。例如，考虑下面的表达式：
$e' \triangleq (\lambda ( f : \mathsf{num} \Arrow \mathsf{num} (\lambda(x:\mathsf{num})f(0))(7))(e)$
在使用动态作用域求值的时候，$e'$的值是$7$，然而在静态作用域下，$e'$的值是$42$。
这种差异可以追溯到，在$e$的值，也就是$v'$应用到$0$上之前，x重新绑定到7，从而改变了结果。

动态作用域违反了第一章中定义的通过避免捕获的替换赋予变量含义的基本原则。
违反这一原则至少会造成两种不良后果。
一个是绑定变量的名称是有用的，与静态范围不同，静态作用域遵循这个识别原则。
例如，如果$e'$的最内层$\lambda$抽象绑定变量$y$而不是$x$，那么它的值将是$42$而不是$7$。
这意味着程序的一个组件可能对在另一个组件中选定的绑定变量的名字敏感，这明显违反模块化分解。

另一个问题是，通常而言动态作用域不是类型安全的。例如，考虑表达式
$$e' \triangleq (\lambda(f:\mathsf{num})(\lambda(x:\mathsf{str})f("zero"))(7))(e)$$
在动态作用域下该表达式在试图对$x+y$求值时中止，其中$x$绑定到字符串$"zero"$，无法继续进行。
出于这个原因，动态作用域一直只在所谓的动态类型语言中被倡导，
它通过动态一致性检查来替代静态一致性检查，以确保一种较弱的进展形式。
编译时错误因此转换为运行时错误。

（有关更多关于动态类型的内容请查看第22章，关于动态作用域的内容则在第32章。）
